import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { WebClient } from '@slack/web-api';
import { ReviewResult, PullRequestData } from '../types/pr.types';
import type { KnownBlock } from '@slack/types';

@Injectable()
export class SlackService {
  private readonly logger = new Logger(SlackService.name);
  private readonly client: WebClient;
  private readonly channelId: string;

  constructor(private configService: ConfigService) {
    const token = this.configService.get<string>('SLACK_BOT_TOKEN');
    this.channelId = this.configService.get<string>('SLACK_CHANNEL_ID') || '';
    this.client = new WebClient(token);
    console.log('Slack service initialized');
  }

  async sendPRReview(
    pr: PullRequestData,
    review: ReviewResult,
  ): Promise<void> {
    try {
      const blocks = this.buildReviewBlocks(pr, review);

      await this.client.chat.postMessage({
        channel: this.channelId,
        text: `PR Review: ${pr.title}`,
        blocks,
      });

      console.log(`Sent PR review to Slack for PR #${pr.number}`);
    } catch (error) {
      this.logger.error(`Failed to send Slack message: ${error.message}`);
      throw error;
    }
  }

  private buildReviewBlocks(pr: PullRequestData, review: ReviewResult): KnownBlock[] {
    const assessmentEmoji = {
      APPROVE: '‚úÖ',
      REQUEST_CHANGES: '‚ö†Ô∏è',
      COMMENT: 'üí¨',
    };

    const blocks: KnownBlock[] = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${assessmentEmoji[review.assessment]} PR Review: ${pr.title}`,
          emoji: true,
        },
      } as KnownBlock, // explicit cast helps inference
      {
        type: 'section',
        fields: [
          { type: 'mrkdwn', text: `*Author:*\n${pr.author}` },
          { type: 'mrkdwn', text: `*PR #:*\n<${pr.url}|#${pr.number}>` },
          { type: 'mrkdwn', text: `*Branch:*\n\`${pr.branch}\` ‚Üí \`${pr.baseBranch}\`` },
          { type: 'mrkdwn', text: `*Assessment:*\n${review.assessment}` },
        ],
      } as KnownBlock,
      { type: 'divider' } as KnownBlock,
      {
        type: 'section',
        text: { type: 'mrkdwn', text: `*Summary:*\n${review.summary}` },
      } as KnownBlock,
    ];

    // findings...
    if (review.findings.length > 0) {
      const findingsText = review.findings
        .slice(0, 5)
        .map((finding) => {
          const emoji = {
            bug: 'üêõ',
            security: 'üîí',
            performance: '‚ö°',
            style: 'üé®',
            'best-practice': 'üìö',
          } as Record<string, string>;
          return `${emoji[finding.type]} *${finding.type.toUpperCase()}* [${finding.severity}] - ${finding.file}\n${finding.description}`;
        })
        .join('\n\n');

      blocks.push({
        type: 'section',
        text: { type: 'mrkdwn', text: `*Key Findings:*\n${findingsText}` },
      } as KnownBlock);
    }

    // recommendations...
    if (review.recommendations.length > 0) {
      const recommendationsText = review.recommendations
        .slice(0, 5)
        .map((rec, idx) => `${idx + 1}. ${rec}`)
        .join('\n');

      blocks.push({
        type: 'section',
        text: { type: 'mrkdwn', text: `*Recommendations:*\n${recommendationsText}` },
      } as KnownBlock);
    }

    blocks.push({ type: 'divider' } as KnownBlock);

    // context block ‚Äî now allowed because blocks is KnownBlock[]
    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `ü§ñ Generated by Ollama MCP PR Reviewer | <${pr.url}|View PR on GitHub>`,
        },
      ],
    } as KnownBlock);

    return blocks;
  }

  async sendSimpleMessage(message: string): Promise<void> {
    try {
      await this.client.chat.postMessage({
        channel: this.channelId,
        text: message,
      });

      console.log('Sent message to Slack');
    } catch (error) {
      this.logger.error(`Failed to send Slack message: ${error.message}`);
      throw error;
    }
  }
}