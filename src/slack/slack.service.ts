import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { WebClient } from '@slack/web-api';
import { ReviewResult, PullRequestData } from '../types/pr.types';

@Injectable()
export class SlackService {
  private readonly logger = new Logger(SlackService.name);
  private readonly client: WebClient;
  private readonly channelId: string;

  constructor(private configService: ConfigService) {
    const token = this.configService.get<string>('SLACK_BOT_TOKEN');
    this.channelId = this.configService.get<string>('SLACK_CHANNEL_ID');
    this.client = new WebClient(token);
    this.logger.log('Slack service initialized');
  }

  async sendPRReview(
    pr: PullRequestData,
    review: ReviewResult,
  ): Promise<void> {
    try {
      const blocks = this.buildReviewBlocks(pr, review);

      await this.client.chat.postMessage({
        channel: this.channelId,
        text: `PR Review: ${pr.title}`,
        blocks,
      });

      this.logger.log(`Sent PR review to Slack for PR #${pr.number}`);
    } catch (error) {
      this.logger.error(`Failed to send Slack message: ${error.message}`);
      throw error;
    }
  }

  private buildReviewBlocks(pr: PullRequestData, review: ReviewResult): any[] {
    const assessmentEmoji = {
      APPROVE: '‚úÖ',
      REQUEST_CHANGES: '‚ö†Ô∏è',
      COMMENT: 'üí¨',
    };

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${assessmentEmoji[review.assessment]} PR Review: ${pr.title}`,
          emoji: true,
        },
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Author:*\n${pr.author}`,
          },
          {
            type: 'mrkdwn',
            text: `*PR #:*\n<${pr.url}|#${pr.number}>`,
          },
          {
            type: 'mrkdwn',
            text: `*Branch:*\n\`${pr.branch}\` ‚Üí \`${pr.baseBranch}\``,
          },
          {
            type: 'mrkdwn',
            text: `*Assessment:*\n${review.assessment}`,
          },
        ],
      },
      {
        type: 'divider',
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Summary:*\n${review.summary}`,
        },
      },
    ];

    // Add findings if any
    if (review.findings.length > 0) {
      const findingsText = review.findings
        .slice(0, 5) // Limit to 5 findings to avoid message size limits
        .map((finding) => {
          const emoji = {
            bug: 'üêõ',
            security: 'üîí',
            performance: '‚ö°',
            style: 'üé®',
            'best-practice': 'üìö',
          };
          return `${emoji[finding.type]} *${finding.type.toUpperCase()}* [${finding.severity}] - ${finding.file}\n${finding.description}`;
        })
        .join('\n\n');

      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Key Findings:*\n${findingsText}`,
        },
      });
    }

    // Add recommendations
    if (review.recommendations.length > 0) {
      const recommendationsText = review.recommendations
        .slice(0, 5)
        .map((rec, idx) => `${idx + 1}. ${rec}`)
        .join('\n');

      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Recommendations:*\n${recommendationsText}`,
        },
      });
    }

    blocks.push({
      type: 'divider',
    });

    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `ü§ñ Generated by Ollama MCP PR Reviewer | <${pr.url}|View PR on GitHub>`,
        },
      ],
    });

    return blocks;
  }

  async sendSimpleMessage(message: string): Promise<void> {
    try {
      await this.client.chat.postMessage({
        channel: this.channelId,
        text: message,
      });

      this.logger.log('Sent message to Slack');
    } catch (error) {
      this.logger.error(`Failed to send Slack message: ${error.message}`);
      throw error;
    }
  }
}